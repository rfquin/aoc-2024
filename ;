module Day3 where

import Data.Char
import Data.List
import Control.Applicative

newtype Parser a = Parser (String -> Maybe (String, a))

parse :: Parser a -> String -> Maybe (String,a)
parse (Parser a) s = a s

instance Functor Parser where
  fmap f (Parser p) = Parser $ fmap (fmap f) . p

instance Applicative Parser where
  pure x = Parser $ \s -> Just (s,x)
  Parser f <*> Parser x =
    Parser $ \s ->
    do
      (s',f') <- f s
      fmap f' <$> x s'

instance Monad Parser where
  return = pure
  Parser p >>= f =
    Parser $ \s ->
    do
      (s',a) <- p s
      let Parser p' = f a
      (p' s')

instance Alternative Parser where
  empty = Parser $ const Nothing
  Parser p1 <|> Parser p2 =
    Parser $ \s -> p1 s <|> p2 s

clean :: Parser String
clean = Parser $ \s -> if parse (parseString "mul") s == Nothing then parse clean (drop 1 s) else Just (s, "")

parseLine :: Parser [Int]
parseLine = do
  result <- parseMul
  rest <- parseLine <|> return []
  return (result : rest)

parseMul :: Parser Int
parseMul = do
  _ <- clean
  _ <- parseString "mul"
  parseParam

parseParam :: Parser Int
parseParam = do
  _ <- parseChar '('
  p1 <- parseInt
  _ <- parseChar ','
  p2 <- parseInt
  _ <- parseChar ')'
  return (p1 * p2)

parseTest :: Parser Char
parseTest = do
  x <- parseChar '('
  return x

parseString :: String -> Parser String
parseString = sequenceA . map parseChar

parseChar :: Char -> Parser Char
parseChar p = Parser $ \s -> case s of
  (x:xs) -> if (x == p) then Just (xs,p) else Nothing
  _ -> Nothing

parseInt :: Parser Int
parseInt = Parser $ \s ->
  case s of
    (x:_) | isDigit x ->
      case parse parseDigits s of
        Just (rest, digits) -> Just (rest, read digits)
        Nothing -> Nothing
    _ -> Nothing

parseDigits :: Parser String
parseDigits = Parser $ \s -> let (dig, rest) = span isDigit s in Just (rest, dig)

day03 :: IO()
day03 = do
  input <- readFile "inputs/day3-input.txt"
  case parse parseLine input of
    Just (_, results) -> putStrLn $ show $ sum (results)
    Nothing -> putStrLn "oopsie"
